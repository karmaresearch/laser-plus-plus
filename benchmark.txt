0. Description of experiments:

Rules are of the form: 
head := body

Operators:
&& - AND
[D] - Diamond
[B] - Box
[$, n] - Time Window of size "n"

Programs**: 

- ATOM
r(X, Y) := p(X, Y)

- CON1
r(X, Y) := p(X,Y) && q(X)

- CON2
r(X, Y, Z) := p(X,Y) && q(Z)

- DIAM
r(X) := [$, 3] [D]p(X)

- BOX
r(X) := [$, 3] [B]p(X)

- EX1S / EX1R *
q(X, a) && r(a, b, Y) := p(X, Y)

- EX8S / EX8R *
a(X, a) := p(X)
b(X, b) := q(X)
c(X, c) := r(X)
d(X, d) := s(X)
e(X, e) := t(X)
f(X, f) := u(X)
g(X, g) := v(X)
h(X, h) := w(X)

- TRAN
p(X, Z) := p(X, Y) && p(Y, Z)


* S/R in EX1 and EX8 indicate the chase algorithm used: Skolem / Restricted 

** All tests are executed on 1000 timepoint, with 1000 facts in the input at each
timepoint. 
Exception 1: CON2 - only 100 timepoints. 
Exception 2: TRAN - 10 timepoints, 100 facts at each timepoint


==============================================================================

I. Benchmark before / after implementing second tier SNE:

The values in the tables represent total evaluation time in seconds. 

-------------------------------------
| Program | Tier 1 SNE | Tier 2 SNE |
-------------------------------------
| ATOM    |       1.61 |       1.13 |
| CON1    |       8.85 |       4.66 |
| CON2    |     102.71 |      40.40 |
| DIAM    |       5.88 |       5.44 |
| BOX     |       0.86 |       0.83 |
| EX1S    |       4.46 |       2.57 |
| EX1R    |      36.92 |       5.23 |
| EX8S    |       2.96 |       2.04 |
| EX8R    |       5.72 |       2.96 |
| TRAN    |       9.54 |       2.80 | 
-------------------------------------

Conclusions:
- Programs using conjunctions are twice as fast after implementing Tier 2 SNE
- Restricted chase is faster. Specifically EX1R, which presents two atoms in the 
  head of the rule, is 6 times faster. Restricted chase uses a conjunctive 
  formula in the head of the rule to assess whether or not a substitution of the 
  body of the rule matches a substitution of the head.
- As expected, the transitive clause is much faster using Tier 2 SNE.
- Restricted chase is still slower than Skolem chase, and I expect is gets even
  slower for rules which have multiple atoms in the head. 


============================================================================

II. Skolem chase with and without hashes:

- The initial implementation of Skolem chase used an unordered map to avoid 
  generating new labeled-null values. 
- Substitutions of the body of a rule would be hashed and used as keys in this 
  unordered map.
- In order to provide a collision free solution, the current implementation 
  uses an ordered map, where the values are compared rather than hashed. 


--------------------------------------
| Program | With hashes | No Hashes  |
--------------------------------------
| EX1S    |        2.57 |       3.59 |
| EX8S    |        2.04 |       2.26 |
--------------------------------------

Conclusions:
- Hashes are faster, but they introduce the possibility of collisions, and thus
  can yield an incorrect result.
- Slowdown are more evident in EX1 than in EX8, since the rule in EX1 has more
  values that need to be compared, while each rule in EX8 only needs to compare
  one value.

  ===========================================================================

  III. Box with and without hashes

- The implementation of the box operator was using an unordered map to track
  facts wich had the same constants. 
- The key of this map was a hash of this constant vector.
- In the current implementation I replaced the hash with a string that is a
  concatentation of all constant values in each fact, separated by semicolon. 
- A binary search tree-based ordered map is used instead of an unordered map.


--------------------------------------
| Program | With hashes | No Hashes  |
--------------------------------------
| BOX    |        0.83 |        2.31 |
--------------------------------------

Conclusions:
- While this implementation eliminates the possibility of collisions, it 
  introduces a significant performance overhead.
- A better solution is needed.
- A similar solution is used in Conjunction. Therefore, finding a more efficient
  solution will benefit the implementation of both Box and Conjunction operators 


