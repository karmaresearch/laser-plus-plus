0. Description of experiments:

Rules are of the form: 
head := body

Operators:
&& - AND
[D] - Diamond
[B] - Box
[$, n] - Time Window of size "n"

Programs**: 

- ATOM
r(X, Y) := p(X, Y)

- CON1
r(X, Y) := p(X,Y) && q(X)

- CON2
r(X, Y, Z) := p(X,Y) && q(Z)

- DIAM
r(X) := [$, 3] [D]p(X)

- BOX
r(X) := [$, 3] [B]p(X)

- EX1S / EX1R *
q(X, a) && r(a, b, Y) := p(X, Y)

- EX8S / EX8R *
a(X, a) := p(X)
b(X, b) := q(X)
c(X, c) := r(X)
d(X, d) := s(X)
e(X, e) := t(X)
f(X, f) := u(X)
g(X, g) := v(X)
h(X, h) := w(X)

- TRAN
p(X, Z) := p(X, Y) && p(Y, Z)


* S/R in EX1 and EX8 indicate the chase algorithm used: Skolem / Restricted 

** All tests are executed on 1000 timepoint, with 1000 facts in the input at each
timepoint. 
Exception 1: CON2 - only 100 timepoints. 
Exception 2: TRAN - 10 timepoints, 100 facts at each timepoint


==============================================================================

I. Benchmark before / after implementing second tier SNE:

The values in the tables represent total evaluation time in seconds. 

-------------------------------------
| Program | Tier 1 SNE | Tier 2 SNE |
-------------------------------------
| ATOM    |       1.61 |       1.13 |
| CON1    |       8.85 |       4.66 |
| CON2    |     102.71 |      40.40 |
| DIAM    |       5.88 |       5.44 |
| BOX     |       0.86 |       0.83 |
| EX1S    |       4.46 |       2.57 |
| EX1R    |      36.92 |       5.23 |
| EX8S    |       2.96 |       2.04 |
| EX8R    |       5.72 |       2.96 |
| TRAN    |       9.54 |       2.80 | 
-------------------------------------

Conclusions:
- Programs using conjunctions are twice as fast after implementing Tier 2 SNE
- Restricted chase is faster. Specifically EX1R, which presents two atoms in the 
  head of the rule, is 6 times faster. Restricted chase uses a conjunctive 
  formula in the head of the rule to assess whether or not a substitution of the 
  body of the rule matches a substitution of the head.
- As expected, the transitive clause is much faster using Tier 2 SNE.
- Restricted chase is still slower than Skolem chase, and I expect is gets even
  slower for rules which have multiple atoms in the head. 


============================================================================

II. Skolem chase with and without hashes:

- The initial implementation of Skolem chase used an unordered map to avoid 
  generating new labeled-null values. 
- Substitutions of the body of a rule would be hashed and used as keys in this 
  unordered map.
- In order to provide a collision free solution, the current implementation 
  uses an ordered map, where the values are compared rather than hashed. 


--------------------------------------
| Program | With hashes | No Hashes  |
--------------------------------------
| EX1S    |        2.57 |       3.59 |
| EX8S    |        2.04 |       2.26 |
--------------------------------------

Conclusions:
- Hashes are faster, but they introduce the possibility of collisions, and thus
  can yield an incorrect result.
- Slowdown are more evident in EX1 than in EX8, since the rule in EX1 has more
  values that need to be compared, while each rule in EX8 only needs to compare
  one value.

===========================================================================

III. Box with and without hashes

- The implementation of the box operator was using an unordered map to track
  facts which had the same constants. 
- The key of this map was a hash of this constant vector.
- In the current implementation I replaced the hash with a string that is a
  concatenation of all constant values in each fact, separated by semicolon. 
- A binary search tree-based ordered map is used instead of an unordered map.


--------------------------------------
| Program | With hashes | No Hashes  |
--------------------------------------
| BOX    |        0.83 |        2.31 |
--------------------------------------

Conclusions:
- While this implementation eliminates the possibility of collisions, it 
  introduces a significant performance overhead.
- A better solution is needed.
- A similar solution is used in Conjunction. Therefore, finding a more efficient
  solution will benefit the implementation of both Box and Conjunction operators 

===========================================================================

IV. Optimizing Box

- I tested three different solutions: 
    S1. A concatenated string is used as the key to an ordered map, just like in 
      III, but the concatenation is more efficient since it is now using 
      std::accumulate. 
    S2. Same as 1., but an unordered map is used. 
    S3. An ordered map is used where the key is the vector of strings as is, 
       without concatenating all values in a single string. 
- To ensure that I find the best solution, I run different experiments on
  different input shapes, different window sizes, and different number of 
  variables in the box atoms

Programs used in experiments:

- BOX1:
r(X) := [$, win_size] [B]p(X)

- BOX2:
r(A, B) := [$, win_size] [B]p(A, B)

- BOX3:
r(A, B, C, D) := [$, win_size] [B]p(A, B, C, D)

- BOX4:
r(A, B, C, D, E, F, G, H) := [$, win_size] [B]p(A, B, C, D, E, F, G, H)

Results:

------------------------------------------------------------------
| Prog |    shape*  | win_size | #var |   S1   |   S2   |   S3   | 
------------------------------------------------------------------
| BOX1 |  1000x1000 |        3 |    1 |  0.87  |  0.75  |  1.08  |
| BOX1 |  10x100000 |        3 |    1 |  0.97  |  0.81  |  1.21  |
| BOX1 |  100000x10 |        3 |    1 |  0.87  |  0.67  |  1.07  |
| BOX1 |  1000x1000 |        9 |    1 |  0.86  |  0.74  |  1.07  |
| BOX1 |  1000x1000 |       27 |    1 |  0.86  |  0.74  |  1.08  |
| BOX2 |  1000x1000 |        3 |    2 |  1.43  |  0.94  |  2.13  |
| BOX3 |  1000x1000 |        3 |    4 |  1.34  |  0.93  |  1.77  |
| BOX4 |  1000x1000 |        3 |    8 |  1.66  |  1.24  |  2.03  |
------------------------------------------------------------------

Conclusions:
- Solution S2 presents the best performance, however, it is using an 
  std::unordered_map with a string as a key. The implementation of 
  std::unordered_map will compute a hash of the string and use it as a key in
  the map. Therefore, our objective of removing any possibility of collisions is
  not satisfied by this solution
- Solution S1 presents a good performance while ensuring a collision-free 
  implementation. 

===========================================================================

V. Chase algorithms compared 

- This time I am running diferent input shapes
- Program: EX1
- Shape:
    - SHORT: Timepoints = 10; Fact_Count = 10000;
    - MED: Timepoints = 1000; Fact_Count = 1000;
    - LONG: Timepoints = 10000; Fact_count = 10;
- Indexed chase alg used an ordered std::map, while Unordered used an std::unordered_map
- It apaears that unordered_map has built machanisms to avoid collisions:
https://stackoverflow.com/questions/21518704/how-does-c-stl-unordered-map-resolve-collisions/21519560#21519560
Therefore I can use unordered map for a bit of extra performance

---------------------------------------------------------------
| Shape    |     Skolem | Restricted |    Indexed | Unordered |
---------------------------------------------------------------
| SHRT     |       4.94 |       7.95 |       8.86 |      8.62 |
| MED      |       3.63 |       5.30 |       5.96 |      5.78 |
| LONG     |       3.44 |       4.99 |       5.41 |      5.42 |
---------------------------------------------------------------

Conclusions:
- Indexed performs worse than normal Restricted chase on all input shapes.

===========================================================================

VI. Will indexed restricted chase improve performance in certain scenarios?

- Program:
    s(c) && t(A, B, c, D) && u(c, D)  := p(A) && q(B) && r(D)\n"
    t(A, B, C, D) := [$, 2] [D] (p(A) && p(B) && p(C) && p(D)) \n"
    t(A, B, C, D) := [$, 2] [D] (q(A) && q(B) && q(C) && q(D)) \n"
    t(A, B, C, D) := [$, 2] [D] (r(A) && r(B) && r(C) && r(D)) \n"
    t(A, B, C, D) := [$, 2] [D] (s(A) && s(B) && s(C) && s(D)) \n"
    u(A, B) := [$, 2] [D] (p(A) && p(B)) \n"
    u(A, B) := [$, 2] [D] (q(A) && q(B)) \n"
    u(A, B) := [$, 2] [D] (r(A) && r(B)) \n"
    u(A, B) := [$, 2] [D] (s(A) && s(B)) \n";
- wsize = 2
- Shape: see experiment V. 


--------------------------------------
| Shape    | Restricted |    Indexed |
--------------------------------------
| SHRT     |        |        |
| MED      |        |        |
| LONG     |        |        |
--------------------------------------

