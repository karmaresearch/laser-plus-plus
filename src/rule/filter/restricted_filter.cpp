#include "rule/filter/restricted_filter.h"

namespace laser {
namespace rule {

ChaseFilter *RestrictedFilter::create() const {
    auto result = new RestrictedFilter();
    return result;
}

RestrictedFilter::~RestrictedFilter() { delete head_formula; }

ChaseFilter *RestrictedFilter::clone() const {
    auto result = new RestrictedFilter();
    result->frontier_variables = this->frontier_variables;
    result->head_variables = this->head_variables;
    result->free_variables = this->free_variables;
    result->bound_variables = this->bound_variables;
    result->free_variable_index = this->free_variable_index;
    result->bound_variable_index = this->bound_variable_index;
    result->null_value_count = this->null_value_count;
    result->head_formula = &this->head_formula->clone();
    return result;
}

ChaseFilter *RestrictedFilter::move() {
    auto result = new RestrictedFilter();
    result->frontier_variables = std::move(this->frontier_variables);
    result->head_variables = std::move(this->head_variables);
    result->free_variables = std::move(this->free_variables);
    result->bound_variables = std::move(this->bound_variables);
    result->free_variable_index = std::move(this->free_variable_index);
    result->bound_variable_index = std::move(this->bound_variable_index);
    result->null_value_count = this->null_value_count;
    result->head_formula = &this->head_formula->move();
    return result;
}

void RestrictedFilter::init(std::vector<formula::Formula *> const &head_atoms,
                            std::vector<std::string> const &head_variables,
                            std::vector<std::string> const &free_variables,
                            std::vector<std::string> const &bound_variables) {
    this->head_variables = head_variables;
    this->free_variables = free_variables;
    this->bound_variables = bound_variables;
    this->free_variable_index = rule::shared::make_index(free_variables);
    this->bound_variable_index = rule::shared::make_index(bound_variables);
    this->head_formula = build_head_formula(0, head_atoms);
    init_frontier_variables(head_atoms);
}

void RestrictedFilter::update(util::Timeline const &timeline,
                              size_t previous_step,
                              util::Database const &database) {
    auto const &facts = database.get_data_full();
    head_formula->evaluate(timeline, previous_step, facts);
    // TODO we might want to store results in a grounding table, since we don't
    // want some conclusions to be skipped due to SNE. Alternative, disable
    // SNE in conjunction if (is_head_m == true) {}
    // If we do use local grounding table, get conclusions here using
    // head_formula.get_conclusions_step(timeline);
}

std::vector<std::shared_ptr<util::Grounding>>
RestrictedFilter::build_chase_facts(
    util::Timeline const &timeline, size_t previous_step,
    std::vector<std::shared_ptr<util::Grounding>> const &input_facts) {
    std::vector<std::shared_ptr<util::Grounding>> result;
    auto database_facts = head_formula->get_conclusions_timepoint(timeline);
    auto current_time = timeline.get_time();
    for (auto const &input_fact : input_facts) {
        if (input_fact->is_fresh_sne(current_time, previous_step) &&
            !has_database_match(database_facts, input_fact)) {
            auto chase_fact = generate_chase_fact(input_fact);
            result.push_back(chase_fact);
        }
    }
    return result;
}

std::shared_ptr<util::Grounding> RestrictedFilter::generate_chase_fact(
    std::shared_ptr<util::Grounding> const &input_fact) {
    std::vector<std::string> chase_values;
    std::vector<std::string> bound_values;
    for (auto const &var_name : bound_variables) {
        auto new_null = generate_new_value(var_name);
        bound_values.push_back(std::move(new_null));
    }
    for (auto const &var_name : head_variables) {
        if (bound_variable_index.count(var_name) > 0) {
            auto index = bound_variable_index.at(var_name);
            auto value = bound_values.at(index);
            chase_values.push_back(value);
        } else {
            auto index = free_variable_index.at(var_name);
            auto value = input_fact->get_constant(index);
            chase_values.push_back(value);
        }
    }
    auto result = input_fact->clone();
    result->set_constant_vector(chase_values);
    return result;
}

std::string RestrictedFilter::generate_new_value(std::string const &var_name) {
    // TODO
    // The value needs to be more random, as is two rules have the same
    // existential quantified variable names, the same null value will be
    // generated by diferent rules.
    // But introducing random names complicates automatic testing.
    // TODO
    // TODO also make sure diferent rules don't generate the same value
    std::string result = var_name + std::to_string(null_value_count);
    null_value_count++;
    return result;
}

bool RestrictedFilter::has_database_match(
    std::vector<std::shared_ptr<util::Grounding>> const &database,
    std::shared_ptr<util::Grounding> const &input_fact) const {
    for (auto const &db_fact : database) {
        if (is_free_variable_match(db_fact, input_fact)) {
            return true;
        }
    }
    return false;
}

bool RestrictedFilter::is_free_variable_match(
    std::shared_ptr<util::Grounding> const &db_fact,
    std::shared_ptr<util::Grounding> const &input_fact) const {
    // TODO should I check all annotations or is ht enough?
    for (auto const &var_name : frontier_variables) {
        auto input_index = free_variable_index.at(var_name);
        auto const &input_value = input_fact->get_constant(input_index);
        auto db_index = head_formula->get_variable_index(var_name);
        auto const &db_value = db_fact->get_constant(db_index);
        if (db_value != input_value) {
            return false;
        }
    }
    // return false if there is a match but the new grounding expires later
    return input_fact->get_horizon_time() <= db_fact->get_horizon_time();
}

formula::Formula *RestrictedFilter::build_head_formula(
    size_t index, std::vector<formula::Formula *> const &list) const {
    // TODO check if clone is properly implemented in Atom, TimeReference & Conj
    if (index == list.size() - 1) {
        auto result = &list[index]->clone();
        result->set_head(false);
        return result;
    }
    auto left = &list[index]->clone();
    left->set_head(false);
    auto right = build_head_formula(index + 1, list);
    return new formula::Conjunction(left, right, true);
}

void RestrictedFilter::init_frontier_variables(
    std::vector<formula::Formula *> const &head_atoms) {
    // I am igniring the time variable here, else I will always get new values
    // at each timepoint
    std::set<std::string> atom_variable_set;
    for (auto atom : head_atoms) {
        auto variable_names = atom->get_variable_names();
        if (atom->get_type() == formula::FormulaType::TIME_REFERENCE) {
            // Time variable is always the last
            std::copy(
                variable_names.begin(), variable_names.end() - 1,
                std::inserter(atom_variable_set, atom_variable_set.end()));
        } else {
            std::copy(
                variable_names.begin(), variable_names.end(),
                std::inserter(atom_variable_set, atom_variable_set.end()));
        }
    }

    for (auto const &variable : bound_variables) {
        atom_variable_set.erase(variable);
    }
    std::copy(atom_variable_set.begin(), atom_variable_set.end(),
              std::back_inserter(frontier_variables));
}

void RestrictedFilter::expire_outdated_groundings(
    util::Timeline const &timeline) {
    head_formula->expire_outdated_groundings(timeline);
}

} // namespace rule
} // namespace laser
